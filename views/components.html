<div class="hero-unit">
  <h1>
  Components
  </h1>
</div>

<div class="container" data-spy="scroll" data-target=".navbar-components">
  <div class="row">

    <div class="span3" class="navbar-components">
      <ul class="nav nav-list affix-top">
        <li>
          <a href="#widget">Widget</a>
        </li>
        <li>
          <a href="#view">View</a>
        </li>
        <li>
          <a href="#model">Model</a>
        </li>
        <li>
          <a href="#style">Style</a>
        </li>
        <li>
          <a href="#fragment">Fragment</a>
        </li>
        <li>
          <a href="#kofactory">ko.factory</a>
        </li>
      </ul>
    </div>


    <div class="span9" data-offset="0">
      <section id="widget">
        <section>
          <h1 class="page-header">Widget</h1>
          MortarJs Widget is a core component that integrates with jQuery's plugin ecosystem by leveraging jQuery UI widget factory. Its primary purpose is to gracefully handle asynchronous operations such as loading dynamic html fragments, data models, and style sheets in order to promote authoring of self contained modular components.
          <h2>How do you use Widget?</h2>
        </section>

        <section class="jscode">
          <h3>1. Define your Widget</h3>
          <p>In this step, you define default options, constructor, and a destructor.  These are generally the only bits you will ever need when defining a Widget. But since the underlying engine is jQuery UI widget factory, you can specify other properties/methods that jQuery UI widget factory can use.  Please see <a href="http://jqueryui.com/widget/" target="jqueryui">jQuery UI widget factory</a> for more details.</p>

          <textarea>
widget("mortar.main", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>


        <section class="FYI">
          <h4>FYI</h4>
          <p><i>1. MortarJs Widget provides the same core interfaces as jQuery UI widget factory to enable a migration path from existing jQuery systems.</i></p>
          <p>2. Widget names must conform to the namespace.name requirement imposed by jQuery UI widget factory.  So, a valid widget name is "mortar.main", but not "main" or "mortar".</p>
        </section>

        <section class="jscode">
          <h3>2. Instantiate your Widget</h3>
          <p>Since MortarJs Widgets are jQuery plugins, you would just use them as such.</p>

          <textarea>
$("body").main();
          </textarea>
        </section>


        <section class="jscode">
          <h3>3. Give domain specific meaning to your Widget!</h3>
          <p>An important part of modern Web Appplications is dynamically loading data from a server on demand. And in more advanced scenarios, dynamically loading html fargments, which we also call html templates that are used for rendering your data.  Both of these are fundamental aspects of a solid SPA (Single Page Application). MortarJs Widget makes this easy for you by loading both html fragments and server data, and then synchronizing these operations.</p>

          <textarea>
widget("mortar.main", {
  // Default options
  options: {
    template: {
      "url": "http://template.html"
    },
    model: {
      "url": "http://data.json"
    }
  },

  // Callback when widget is ready for business
  _create: function() {
    console.log("Your html template and server data are loaded at this point");
    init( this );
  },

  // Destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>

        <section class="jscode">
          <p>When the _create function is called, all the relevant dynamic and asynchronous operations are finished and you are ready to add business logic to the Widget instance. Some very common operations are to add event listeners/handlers and to instantiate other Widgets and Views that are to be contained by a Widget instance.</p>
          <p>In practice, a MortarJs Widget instance is a jQuery UI widget instance so, everything that a jQuery UI widget instance provides is also available in a MortarJs Widget instance.</p>

          <textarea>
function init( wInstance ) {
  // Add event handler
  wInstance.element.on("click", ".cancel", function(evt) {
    console.log("Handle click");
  })
  .on("submit", ".checkEmail", function(evt) {
    console.log("Send request to check email");
    evt.stopPropagation();
    return false;
  });

  // Call another Widget or View.
  wInstance.element.find(".anotherContainer").anotherWidget();
}
          </textarea>
        </section>


        <section class="FYI">
          <h4>FYI</h4>
            <!--
          <p>1. A common issue for KnockoutJs developers is knowing when to call ko.applyBindings and that it can be done <i>only</i> once.  MortarJs Widget takes care of this for you.</p>
          <p>2. Another common problem when developing with KnockoutJs is cleanly separating view models, especially when dealing with nested UI components and view models are not supposed to cascade down.</p>
            -->
        </section>
      </section>

      <section id="view">
        <h1 class="page-header">View</h1>
        <p>MortarJs View is an extension of Widget where html fragments and style sheets are loaded automatically, without any special configuration.  Its purpose is to make authoring of UI components easier.  All rules in MortarJs Widgets and jQuery UI widget apply.</p>

        <section class="jscode">
          <textarea>
view("mortar.main", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>

        <section>
          <p><i>
            * By simply defining a View, with very little effort you have created a place for your domain specific logic (JavaScript), your presentation (HTML), and look and feel (CSS)!
          </i></p>

          <p><i>Let's dissect this code...</i> The View in this example is called main (namespace is mortar). So when a main View is instantiated two things happen.</p>
          <p>
            1. A template with name "main.html" is loaded<br/>
            2. A style sheet with name "main.css" is loaded<br/>
          </p>
          <p>The name of the html fragment and style sheet is derived from the name of the View itself, hence main.html and main.css.</p>
        </section>

        <section>
          <p><b>CSS note: </b>An important thing that happens when a View is instantiated is that its name (E.g. main) gets automatically added as a css class to the containing DOM element. This provides a very clean way to scope all the css rules in the css file for the View, which really helps avoid cross contamination with other UI components and their respective css.</p>
          <p>To illustrate this please consider two UI controls: menu and dropdown.  Generally both depend on a dom hierarchy with anchors containing user data.  If you want the anchors in the menus and dropdowns to look different, you would normally create css rules that target anchors in .menus and .dropdown.  If the menu and dropdown were views, you would simply use the menu.css and dropdown.css that are automatically loaded by the views.</p>

          <section class="jscode">

            <textarea>
view("mortar.menu", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
            </textarea>
          </section>
          <section class="jscode">
            <textarea>
.menu a {
  color: blue;
}
            </textarea>
          </section>

          <hr>

          <section class="jscode">
            <textarea>
view("mortar.dropdown", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
            </textarea>
          </section>

          <section class="jscode">
            <textarea>
.dropdown a {
  color: red;
}
            </textarea>
          </section>
        </section>

        <section>
          <p><b>KnockoutJs note: </b>When a model is loaded, it is <i>only</i> applied to the html of the View at the time of its creation.  This has a rather important implication, especially if you are loading dynamic html fragments.  View models do not propagate down into children Views, which is a very disired behavior in larger web applications.</p>
          <p><i>* When view models don't propagate down to children Views, you can safely nest Views with independent view models.</i></p>
          <p>To illustrate, think of a web application with multiple sections (Views) where users can trigger server requests; Search and Email notifications. When a user triggers a request for Search, data for Email notifications really shouldn't be sent to the server. Using Views to break up Search and Email notifications allows you to have completely separate view models and event handlers.</p>

          <section class="jscode">
            <textarea>
view("mortar.search", {
  // Default options
  options: {
    model: {
      search: {
        text: "Maverick"
      }
    }
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
    init( this );
  },

  // @destructor
  _destroy: function() {
  }
});


function init(wInstance) {
  wInstance.on("click", ".getSearchResults", function(evt) {
    var data = ko.dataFor(this);
    data = ko.mapping.toJs(data);

    $.ajax({
      url: "http://dummy/search",
      data: data
    });
  });
}
            </textarea>
          </section>

          <hr/>

          <section class="jscode">
            <textarea>
view("mortar.emailNotifications", {
  // Default options
  options: {
    model: {
      when: "lastFiveHours"
    }
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
    init( this );
  },

  // @destructor
  _destroy: function() {
  }
});


function init(wInstance) {
  wInstance.on("click", ".getEmailNotifications", function(evt) {
    var data = ko.dataFor(this);
    data = ko.mapping.toJs(data);

    $.ajax({
      url: "http://dummy/emailNotifications",
      data: data
    });
  });
}
            </textarea>
          </section>

        </section>

        <section>
          <p>* By default, your views are expected to be in a folder called views. In more advanced uses, you can configure a view factory where you can specify the folder where your views can be found.</p>
        </section>
      </section>

      <section id="model">
        <section>
          <h1 class="page-header">Model</h1>
          <p>MortarJs Model is an extension of Widget that provides a transparent system for loading data into your Widgets and Views.  Data can be loaded from a remote or local data source, and it is 100% KnockoutJs compatible.</p>
        </section>

        <section class="jscode">
          <p>You can configure Widgets and Views to have a default data model</p>
          <textarea>
View("mortar.main", {
  options: {
    model: {
      say: "Hello World"
    },
  }
});
          </textarea>
        </section>

        <section class="jscode">
          <p>You can also just load data when instantiating a Widget or View.</p>
          <p>Loading a model into a Widget or View instance has the added benefit that it guarantees that ko.applyBindings is only done once, even if you invoke model multiple times.</p>
          <textarea>
$("body").main({
  model: {
    say: "Hello World"
  },
});
          </textarea>
        </section>

        <section class="jscode">
          <p>Another feature of model is that it <i>only</i> applies the binding to the specific Widget or View DOM; it does not apply the binding to the entire document.</p>
          <textarea>
// This
ko.applyBindings(model, $element);

// instead of
ko.applyBindings(model);
          </textarea>
        </section>



        <section class="jscode">
          <p>Since Model is an extension of Widget, it is a jQuery plugin.  Hence, you can call model on any jQuery object.</p>
          <textarea>
$("body").model({
  say: "Hello World"
});
          </textarea>
        </section>
      </section>

      <section id="style">
        <h1 class="page-header">Style</h1>
        <p>derived from widget to provide a transparent system for loading style sheets dynamically from a url or locally.</p>
      </section>

      <section id="fragment">
        <h1 class="page-header">Fragment</h1>
        <p>derived from widget to provide a transparent system for loading html fragments dynamically from a url or locally.</p>
      </section>

      <section id="kofactory">
        <h1 class="page-header">Ko Factory</h1>
        <p>provides a simple interface to create KnockouJs observables.  It is designed for simplicity, efficiency, and speed.</p>
      </section>
    </div>

  </div>
</div>
