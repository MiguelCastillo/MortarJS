<div class="hero-unit">
  <h1>
  Components
  </h1>
</div>

<div class="container" data-spy="scroll" data-target=".navbar-components">
  <div class="row">

    <div class="span3" class="navbar-components">
      <ul class="nav nav-list affix-top">
        <li>
          <a href="#widget">Widget</a>
        </li>
        <li>
          <a href="#view">View</a>
        </li>
        <li>
          <a href="#model">Model</a>
        </li>
        <li>
          <a href="#style">Style</a>
        </li>
        <li>
          <a href="#fragment">Fragment</a>
        </li>
        <li>
          <a href="#kofactory">ko.factory</a>
        </li>
      </ul>
    </div>


    <div class="span9" data-offset="0">
      <section id="widget">
        <section>
          <h1 class="page-header">Widget</h1>
          MortarJs Widget is a core component that integrates with jQuery's plugin ecosystem by leveraging jQuery UI widget factory.  Its primary purpose is to gracefully handle asynchronous operations such as loading dynamic html fragments, data models, and style sheets in order to promote authoring of self contained modular components.
          <h2>How do you use Widget?</h2>
        </section>

        <section class="jscode">
          <h3>1. Define your Widget</h3>
          <p>In this step, you define default options, constructor, and a destructor.  These are generally the only bits you will ever need when defining a Widget. But since the underlying engine is jQuery UI widget factory, you can specify other properties/methods that jQuery UI widget factory can use.  Please see <a href="http://jqueryui.com/widget/" target="jqueryui">jQuery UI widget factory</a> for more details.</p>

          <div class="title">Widget definition</div>
          <textarea>
widget("mortar.main", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>


        <section class="FYI">
          <h4>FYI</h4>
          <p><i>1. MortarJs Widget provides the same core interfaces as jQuery UI widget factory to enable a migration path from existing jQuery systems.</i></p>
          <p>2. Widget names must conform to the namespace.name requirement imposed by jQuery UI widget factory.  So, a valid widget name is "mortar.main", but not "main" or "mortar".</p>
        </section>

        <section class="jscode">
          <h3>2. Instantiate your Widget</h3>
          <p>Since MortarJs Widgets are jQuery plugins, you would just use them as such.</p>

          <div class="title">Widget instance on the document body</div>
          <textarea>
$("body").main();
          </textarea>
        </section>


        <section class="jscode">
          <h3>3. Widgets in the wild!</h3>
          <p>An important part of modern Web Appplications is to dynamically load data on demand, particularly from a remote source. And in more advanced scenarios, to dynamically load html fargments, also refered to as html templates. Both of these are fundamental aspects of a solid SPA (Single Page Application). MortarJs Widget makes this easy for you by loading both html fragments and server data, and then synchronizing these operations.</p>
          <p><i>* Html fragments become very powerful when they contain KnockoutJs data-bind notation used for rendering data models, because Widget is designed to only apply the data model to the html fragment.  This prevents leaking data into other parts of the application, which is particularly important when creating nested Widgets.</i></p>

          <div class="title">Configure an html fragment and data model</div>
          <textarea>
widget("mortar.main", {
  // Default options
  options: {
    template: {
      "url": "http://template.html"
    },
    model: {
      "url": "http://data.json"
    }
  },

  // Callback when widget is ready for business
  _create: function() {
    console.log("Your html template and server data are loaded at this point");
    init( this );
  },

  // Destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>

        <section class="jscode">
          <p>When the _create function is called, all the relevant asynchronous operations are finished and you are ready to add business logic to the Widget instance. Some very common operations are to add event listeners/handlers and to instantiate nested (children) Widgets.</p>
          <p><i>* A MortarJs Widget instance is a jQuery UI widget instance so, everything that a jQuery UI widget instance provides is also available in a MortarJs Widget instance.</i></p>

          <div class="title">Add event handlers and create a nested widget</div>
          <textarea>
function init( wInstance ) {
  // Add event handler
  wInstance.element.on("click", ".cancel", function(evt) {
    console.log("Handle click");
  })
  .on("submit", ".checkEmail", function(evt) {
    console.log("Send request to check email");
    evt.stopPropagation();
    return false;
  });

  // Call another Widget or View.
  wInstance.element.find(".anotherContainer").anotherWidget();
}
          </textarea>
        </section>
      </section>

      <section id="view">
        <h1 class="page-header">View</h1>
        <p>MortarJs View is an extension of Widget where html fragments and style sheets are loaded automatically, without any special configuration.  Its purpose is to make authoring of UI components easier.  All rules in MortarJs Widgets, and therefore jQuery UI widget apply.</p>

        <section class="jscode">
          <div class="title">Define main view</div>
          <textarea>
view("mortar.main", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>

        <section>
          <p><i>
            * With very little effort you have defined a View, which automatically creates a place for your domain specific logic (JavaScript), your presentation (HTML), and look and feel (CSS)!
          </i></p>

          <p>Let's dissect this code... The View in this example is called main (namespace is mortar). So when a main View is instantiated two things happen.</p>
          <p>
            1. A template with name "main.html" is loaded<br/>
            2. A style sheet with name "main.css" is loaded<br/>
          </p>
          <p>The name of the html fragment and style sheet is derived from the name of the View itself, hence main.html and main.css.</p>
        </section>

        <section>
          <p><b>CSS note: </b>An important thing that happens when a View is instantiated is that its name (E.g. main) is automatically added as a css class to the DOM element containing the View. This provides a very clean way to scope all the css rules in the css file for the View, which really helps avoid cross contamination with other UI components and css.</p>
          <p>To illustrate this please consider two UI controls: menu and dropdown.  Generally both depend on a dom hierarchy with anchors containing user data.  If you want the anchors in the menus and dropdowns to look different, you would normally create css rules that target anchors in .menus and .dropdown.  If the menu and dropdown were views, you would simply use the menu.css and dropdown.css that are automatically loaded by the views.</p>

          <section class="jscode">
            <div class="title">Define menu view</div>
            <textarea>
view("mortar.menu", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
            </textarea>
          </section>
          <section class="csscode">
            <div class="title">menu.css with custom anchor</div>
            <textarea>
.menu a {
  color: blue;
}
            </textarea>
          </section>

          <hr>

          <section class="jscode">
            <div class="title">Define dropdown view</div>
            <textarea>
view("mortar.dropdown", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
            </textarea>
          </section>

          <section class="csscode">
            <div class="title">dropdown.css with custom anchor</div>
            <textarea>
.dropdown a {
  color: red;
}
            </textarea>
          </section>
        </section>

        <section>
          <p><b>KnockoutJs note: </b>When a model is loaded, it is <i>only</i> applied to the html content of the View at the time of its creation.  This has a rather important implication, especially if you are loading dynamic html fragments.  View models do not propagate down into children Views, which is a very disired behavior in larger web applications.</p>
          <p><i>* When view models don't propagate down to children Views, you can safely nest Views with independent view models.</i></p>
          <p>To illustrate, think of a web application with multiple sections (Views) where users can trigger server requests; Search and Email notifications. When a user triggers a request for Search, data for Email notifications really shouldn't be sent to the server. Using Views to break up Search and Email notifications allows you to have completely separate view models and event handlers.</p>

          <section class="jscode">
            <div class="title">Define Search view</div>
            <textarea>
view("mortar.search", {
  // Default options
  options: {
    model: {
      search: {
        text: "Maverick"
      }
    }
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
    init( this );
  },

  // @destructor
  _destroy: function() {
  }
});


function init(_widget) {
  _widget.element.on("click", ".getSearchResults", function(evt) {
    var data = ko.dataFor(this);
    data = ko.mapping.toJs(data);

    $.ajax({
      url: "http://dummy/search",
      data: data
    });
  });
}
            </textarea>
          </section>

          <hr/>

          <section class="jscode">
            <div class="title">Define Email notification view</div>
            <textarea>
view("mortar.emailNotifications", {
  // Default options
  options: {
    model: {
      when: "lastFiveHours"
    }
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
    init( this );
  },

  // @destructor
  _destroy: function() {
  }
});


function init(_widget) {
  _widget.element.on("click", ".getEmailNotifications", function(evt) {
    var data = ko.dataFor(this);
    data = ko.mapping.toJs(data);

    $.ajax({
      url: "http://dummy/emailNotifications",
      data: data
    });
  });
}
            </textarea>
          </section>

        </section>

        <section>
          <p><i>* By default, your views are expected to be in a folder called views. In more advanced uses, you can configure a view factory where you can specify the folder for your views.</i></p>
        </section>
      </section>

      <section id="model">
        <section>
          <h1 class="page-header">Model</h1>
          <p>MortarJs Model is an extension of Widget that provides a transparent system for loading data into your Widgets and Views.  Data can be loaded from a remote or local data source, and it is 100% KnockoutJs compatible.</p>
        </section>

        <section class="jscode">
          <p>You can configure Widgets and Views to have a default data model</p>
          <textarea>
View("mortar.main", {
  options: {
    model: {
      say: "Hello World"
    },
  }
});
          </textarea>
        </section>

        <section class="jscode">
          <p>You can also just load data when instantiating a Widget or View.</p>
          <p>Loading a model into a Widget or View instance has the added benefit that it guarantees that ko.applyBindings is only done once, even if you invoke model multiple times.</p>
          <textarea>
$("body").main({
  model: {
    say: "Hello World"
  },
});
          </textarea>
        </section>

        <section class="jscode">
          <p>Another feature of model is that it <i>only</i> applies the binding to the specific Widget or View DOM; it does not apply the binding to the entire document.</p>
          <textarea>
// This
ko.applyBindings(model, $element);

// instead of
ko.applyBindings(model);
          </textarea>
        </section>



        <section class="jscode">
          <p>Since Model is an extension of Widget, it is a jQuery plugin.  Hence, you can call model on any jQuery object.</p>
          <textarea>
$("body").model({
  say: "Hello World"
});
          </textarea>
        </section>
      </section>

      <section id="style">
        <h1 class="page-header">Style</h1>
        <p>derived from widget to provide a transparent system for loading style sheets dynamically from a url or locally.</p>
      </section>

      <section id="fragment">
        <h1 class="page-header">Fragment</h1>
        <p>derived from widget to provide a transparent system for loading html fragments dynamically from a url or locally.</p>
      </section>

      <section id="kofactory">
        <h1 class="page-header">Ko Factory</h1>
        <p>provides a simple interface to create KnockouJs observables.  It is designed for simplicity, efficiency, and speed.</p>
      </section>
    </div>

  </div>
</div>
