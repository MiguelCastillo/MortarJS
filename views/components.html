<div class="hero-unit">
  <h1>
  Components
  </h1>
</div>

<div class="container" data-spy="scroll" data-target=".navbar-components">
  <div class="row">

    <div class="span3" class="navbar-components">
      <ul class="nav nav-list affix-top">
        <li>
          <a href="#widget">Widget</a>
        </li>
        <li>
          <a href="#view">View</a>
        </li>
        <li>
          <a href="#model">Model</a>
        </li>
        <li>
          <a href="#style">Style</a>
        </li>
        <li>
          <a href="#fragment">Fragment</a>
        </li>
        <li>
          <a href="#kofactory">ko.factory</a>
        </li>
      </ul>
    </div>


    <div class="span9" data-offset="0">
      <section id="widget">
        <section>
          <h1 class="page-header">Widget</h1>
          MortarJs Widget is a core component that integrates with the jQuery plugin ecosystem by leveraging the jQuery UI widget factory.  It provides features such as gracefully handling loading of html fragments, data model, and style sheets. But because Widget integrates with the jQuery ecosystem, any jQuery plugin can transparently can take advantage of these features.
        </section>

        <section class="jscode">
          <h2>How do you use Widget?</h2>
          <h3>1. Define your Widget</h3>
          <p>In this step, you define default options, constructor, and a destructor.  These are generally the only bits you will ever need when defining a Widget. And since the underlying engine is jQuery UI widget factory, you can specify other properties/methods that jQuery UI widget factory can consume.  Please see <a href="http://api.jqueryui.com/jQuery.widget/" target="jqueryui">jQuery UI widget factory</a> for more details.</p>
          <ul>
            <li>options is available in each widget instance and can be overriden when instantiating the Widget.</li>
            <li>_create is invoked when all asynchronous operations are finished.  This generally when domain logic is added to the widget. Aka. Setup of event listeners, creation of nested Widgets and so on.</li>
            <li>_destroy is invoked when the method "destroy" is invoked on the Widget instance.  Use this to clean up after yourself.</li>
          </ul>

          <div class="title">Widget definition</div>
          <textarea>
widget("mortar.main", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>


        <section class="FYI">
          <h4>FYI</h4>
          <p><i>1. MortarJs Widget provides the same core interfaces as jQuery UI widget factory to enable a migration path from existing jQuery systems.</i></p>
          <p>2. Widget names must conform to the namespace.name requirement imposed by jQuery UI widget factory.  So, a valid widget name is "mortar.main", but not "main" or "mortar".</p>
        </section>

        <section class="jscode">
          <h3>2. Instantiate your Widget</h3>
          <p>Since MortarJs Widgets are jQuery plugins, you would just use them as such.</p>

          <div class="title">Widget instance on the document body</div>
          <textarea>
$("body").main();
          </textarea>
        </section>

        <section>
          <p>When the Widget is instantiated, the _create function that's the defined in step 1 is invoked.  At that point, all relevant asynchronous operations are finished and you are ready to add business logic to the Widget instance.</p>
        </section>


        <section class="jscode">
          <h3>3. Widgets in the wild!</h3>
          <p>An important part of modern Web Appplications is to dynamically load data on demand, particularly from a remote source. And in more advanced scenarios, to dynamically load html fargments, also refered to as html templates. Both of these are fundamental aspects of a solid SPA (Single Page Application).</p>
          <p>A MortarJs Widget makes this easy for you by synchronizing the process of loading the html fragments and data model, and then doing the data binding.  <i>Widgets will also transparently allow nesting of Widgets without view models butting into each other.</i></p>

          <div class="title">Configure an html fragment and data model</div>
          <textarea>
widget("mortar.main", {
  // Default options
  options: {
    template: {
      "url": "http://template.html"
    },
    model: {
      "url": "http://data.json"
    }
  },

  // Callback when widget is ready for business
  _create: function() {
    console.log("Your html template and server data are loaded and properly bound at this point");
    init( this );
  },

  // Destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>

        <section class="jscode">
          <p><i>* A MortarJs Widget instance is a jQuery UI widget instance. Therefore, everything that a jQuery UI widget instance provides is also available in a MortarJs Widget instance.</i></p>

          <div class="title">Add event handlers and create a nested widget</div>
          <textarea>
function init( _widget ) {
  // Add event handler
  _widget.element.on("click", ".cancel", function(evt) {
    console.log("Handle click");
  })
  .on("submit", ".checkEmail", function(evt) {
    console.log("Send request to check email");
    evt.stopPropagation();
    return false;
  });

  // Call another Widget or View.
  _widget.element.find(".anotherContainer").anotherWidget();
}
          </textarea>
        </section>
      </section>

      <section id="view">
        <h1 class="page-header">View</h1>
        <p>MortarJs View is an extension of Widget where html fragments and style sheets are loaded automatically, without any special configuration.  Its purpose is to make authoring of UI components easier.  All rules in MortarJs Widgets, and therefore jQuery UI widget apply.</p>

        <section class="jscode">
          <div class="title">Define main view</div>
          <textarea>
view("mortar.main", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>

        <section>
          <p><i>
            * With very little effort you have defined a View, which automatically creates a place for your domain specific logic (JavaScript), your presentation (HTML), and look and feel (CSS)!
          </i></p>

          <p>Let's dissect this code... The View in this example is called main (namespace is mortar). So when a main View is instantiated two things happen.</p>
          <p>
            1. A template with name "main.html" is loaded<br/>
            2. A style sheet with name "main.css" is loaded<br/>
          </p>
          <p>The name of the html fragment and style sheet is derived from the name of the View itself, hence main.html and main.css.</p>
        </section>

        <section>
          <p><b>CSS note: </b>An important thing that happens when a View is instantiated is that its name (E.g. main) is automatically added as a css class to the DOM element containing the View. This provides a very clean way to scope all the css rules in the css file for the View, which really helps avoid cross contamination with other UI components and css.</p>
          <p>To illustrate this please consider two UI controls: menu and dropdown.  Generally both depend on a dom hierarchy with anchors containing user data.  If you want the anchors in the menus and dropdowns to look different, you would normally create css rules that target anchors in .menus and .dropdown.  If the menu and dropdown were views, you would simply use the menu.css and dropdown.css that are automatically loaded by the views.</p>

          <section class="jscode">
            <div class="title">Define menu view</div>
            <textarea>
view("mortar.menu", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
            </textarea>
          </section>
          <section class="csscode">
            <div class="title">menu.css with custom anchor</div>
            <textarea>
.menu a {
  color: blue;
}
            </textarea>
          </section>

          <hr>

          <section class="jscode">
            <div class="title">Define dropdown view</div>
            <textarea>
view("mortar.dropdown", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
            </textarea>
          </section>

          <section class="csscode">
            <div class="title">dropdown.css with custom anchor</div>
            <textarea>
.dropdown a {
  color: red;
}
            </textarea>
          </section>
        </section>

      </section>

      <section id="model">
        <section>
          <h1 class="page-header">Model</h1>
          <p>MortarJs Model is an extension of Widget that provides a transparent system for loading data into your Widgets and Views.  Data can be loaded from a remote or local data source, and it is 100% KnockoutJs compatible. A Model guarantees that ko.applyBindings is only done once and that it is done at the appropriate time.</p>
        </section>

        <section class="jscode">
          <div class="title">Configure Widgets and Views with a default data model</div>
          <textarea>
View("mortar.main", {
  options: {
    model: {
      say: "Hello World v1"
    },
  }
});
          </textarea>
        </section>

        <section class="jscode">
          <div class="title">You can also define a model while instantiating a Widget or a View.</div>
          <textarea>
$("body").main({
  model: {
    say: "Hello World v2"
  },
});
          </textarea>
        </section>


        <section class="jscode">
          <div class="title">Since Model is an extension of Widget, it is a jQuery plugin. Hence, you can invoke model on any jQuery object.</div>
          <textarea>
$("body").model({
  say: "Hello World v3"
});
          </textarea>
        </section>


        <section class="jscode">
          <p>MortarJs models <i>only</i> applies the binding to the specific Widget or View DOM; it does not apply the binding to the entire document.</p>
          <textarea>
// This
ko.applyBindings(model, $element);

// instead of
ko.applyBindings(model);
          </textarea>
        </section>
      </section>

      <section id="style">
        <h1 class="page-header">Style</h1>
        <p>derived from widget to provide a transparent system for loading style sheets dynamically from a url or locally.</p>
      </section>

      <section id="fragment">
        <h1 class="page-header">Fragment</h1>
        <p>derived from widget to provide a transparent system for loading html fragments dynamically from a url or locally.</p>
      </section>

      <section id="kofactory">
        <h1 class="page-header">Ko Factory</h1>
        <p>provides a simple interface to create KnockouJs observables.  It is designed for simplicity, efficiency, and speed.</p>
      </section>
    </div>

  </div>
</div>
