<div class="hero-unit">
  <h1>
  Components
  </h1>
</div>

<div class="container" data-spy="scroll" data-target=".navbar-components">
  <div class="row">

    <div class="span3" class="navbar-components">
      <ul class="nav nav-list affix-top">
        <li>
          <a href="#widget">Widget</a>
        </li>
        <li>
          <a href="#view">View</a>
        </li>
        <li>
          <a href="#model">Model</a>
        </li>
        <li>
          <a href="#style">Style</a>
        </li>
        <li>
          <a href="#fragment">Fragment</a>
        </li>
        <li>
          <a href="#kofactory">ko.factory</a>
        </li>
      </ul>
    </div>


    <div class="span9" data-offset="0">
      <section id="widget">
        <h1 class="page-header">Widget</h1>
        MortarJs Widget is a core component that integrates with jQuery's plugin ecosystem by leveraging jQuery UI widget factory. Its primary purpose is to gracefully handle asynchronous operations such as loading dynamic html fragments, data models, and style sheets.
        <h2>How do you use Widget?</h2>
        <h3>1. Define your Widget</h3>
        In this step, you define default options, constructor, and a destructor.  These are generally the only bits you will ever need when defining a Widget. But since the underlying engine is jQuery UI widget factory, you can specify other properties/methods that jQuery UI widget factory can use.  Please see <a href="http://jqueryui.com/widget/" target="jqueryui">jQuery UI widget factory</a> for more details.

        <section class="jscode">
          <textarea>
widget("mortar.main", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>


        <section class="FYI">
          <h4>FYI</h4>
          <p><i>1. MortarJs Widget provides the same core interfaces as jQuery UI widget factory to enable a migration path from existing jQuery systems.</i></p>
          <p>2. Widget names must conform to the namespace.name requirement imposed by jQuery UI widget factory.  So, a valid widget name is "mortar.main", but not "main" or "mortar".</p>
        </section>


        <h3>2. Instantiate your Widget</h3>
        <p>Since MortarJs Widgets are jQuery plugins, you would just use them as such.</p>
        <section class="jscode">
          <textarea>
$("body").main();
          </textarea>
        </section>


        <h3>3. Give domain specific meaning to your Widget!</h3>
        An important part of modern Web Appplications is dynamically loading data from a server as needed, which is fundamental to any SPA (Single Page Application).  And in more advanced scenarios, loading dynamic html templates for rendering your data.  MortarJs Widget makes this easy for you by loading both html fragments and server data, and synchronizing these operations.
        <section class="jscode">
          <textarea>
widget("mortar.main", {
  // Default options
  options: {
    template: {
      "url": "http://template.html"
    },
    model: {
      "url": "http://data.json"
    }
  },

  // Callback when widget is ready for business
  _create: function() {
    console.log("Your html template and server data are loaded at this point");
  },

  // Destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>


        <section class="FYI">
          <h4>FYI</h4>
            <!--
          <p>1. A common issue for KnockoutJs developers is knowing when to call ko.applyBindings and that it can be done <i>only</i> once.  MortarJs Widget takes care of this for you.</p>
          <p>2. Another common problem when developing with KnockoutJs is cleanly separating view models, especially when dealing with nested UI components and view models are not supposed to cascade down.</p>
            -->
        </section>
      </section>

      <section id="view">
        <h1 class="page-header">View</h1>
        <p>MortarJs View is an extension of Widget where html fragments and style sheets are loaded automatically, without any special configuration.  Its purpose is to make authoring of UI components easier.<br/>

        <section class="jscode">
          <textarea>
view("mortar.main", {
  // Default options
  options: {
  },

  // @constructor - callback when widget is ready for business
  _create: function() {
  },

  // @destructor
  _destroy: function() {
  }
});
          </textarea>
        </section>

        <section>
          <i>Let's dissect this code...</i> The View in this example is called main (namespace is mortar). So when a main View is instantiated two things happen.
          <p>
            1. A template with name "main.html" is loaded<br/>
            2. A style sheet with name "main.css" is loaded<br/>
          </p>

          <p>
            The name of the html fragment and style sheet is derived from the name of the View itself, hence main.html and main.css.
          </p>

          <p><i>
            * By simply defining a View, with very little effort you have created a place for your domain specific logic (JavaScript), your presentation (HTML), and look and feel (CSS)!
          </i></p>

          <p>
            Another important thing that happens when a View is instatiated is its name (E.g. main) is automatically added as a css class in the dom element containing it. This provides a very clean way to scope all the css rules in the css file for the View, which really helps avoid collision with all your other css rules.
          </p>

          <p>
            To illustrate this please consider two UI controls: menu and dropdown.  Generally both depend on a dom hierarchy with anchors containing user data.  If you want the anchors in the menus and dropdowns to look different, you would normally create css rules that target anchors in .menus and in .dropdown.  Imagine the menu and dropdown were views?  You would use the menu.css and dropdown.css that are automatically loaded to define the specific css rules.
          </p>

          <p>
            * By default, your views are expected to be in a folder called views. In more advanced uses, you can configure a view factory where you can specify the folder where your views can be found.
          </p>
        </section>
      </section>

      <section id="model">
        <h1 class="page-header">Model</h1>
        <p>
          derived from widget to provides a transparent system for dynamic loading of data from a url or a locally.
        </p>
      </section>

      <section id="style">
        <h1 class="page-header">Style</h1>
        <p>
          derived from widget to provide a transparent system for loading style sheets dynamically from a url or locally.
        </p>
      </section>

      <section id="fragment">
        <h1 class="page-header">Fragment</h1>
        <p>
          derived from widget to provide a transparent system for loading html fragments dynamically from a url or locally.
        </p>
      </section>

      <section id="kofactory">
        <h1 class="page-header">Ko Factory</h1>
        <p>
          provides a simple interface to create KnockouJs observables.  It is designed for simplicity, efficiency, and speed.
        </p>
      </section>
    </div>

  </div>
</div>
